{"pages":[{"title":"About","date":"2020-03-12T10:53:06.365Z","path":"about/index.html","text":""},{"title":"Tags","date":"2020-03-12T10:53:06.367Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2020-03-12T10:53:06.366Z","path":"categories/index.html","text":""}],"posts":[{"title":"Quick Start Typescript ~ 9장 정리","date":"2020-04-12T09:39:05.000Z","path":"wiki/Typescript quick start -9장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 9장 고급 타입📝315p. 유니언 타입1const x: string | number; 📝317p. 타입 가드typeof123456789function myIndexOf(x: number | string, y: string) &#123; if (typeof x === `string`) &#123; return x.indexOf(y); &#125; return -1;&#125;console.log(myIndexOf(`hello`, `e`)) instanceof12345678function diff(x: Cat | Dog) &#123; if (x instanceof Dog) &#123; ... return; &#125; return;&#125; 📝320p. 고급 타입들문자열 리터럴 타입1234567let event; 'keyup' = 'keyup'; // Olet event: 'keyup' = 'keyup2'; // error// ortype EventType = 'keyup' | 'mouseover';const myEvent: EventType = 'keyup'; 룩업 타입 (= 인덱스 타입)keyof 명령어를 통해 타입 T의 하위 타입을 생성, 타입 T는 여러 타입으로 이뤄진 유니언이나 인터페이스 타입을 의미 확장성을 고려해 interface를 도입 12345interface Profile &#123; name: string; gender: string; age: number;&#125; 이 인터페이스를 keyof를 활용하여 룩업 타입으로 선언 1234567891011121314151617181920212223242526// # 1// 이렇게 선언된 변수는 name , gener, age 중 하나를 할당 받기 가능type Profile1 = keyof Profile;let pValue: Profile1 = 'name';// # 2// 배열 타입의 내장 속성인, length, push, pop, concat 등을 할당받아 사용 가능type Profile2 = keyof Profile[];let pValue2: Profile2 = 'length';let pValue3: Profile2 = 'push';// # 3// ??? 이해 안되는 부분// 어느 문자열이든 입력 가능한건가?type Profile3: keyof &#123; [x: string]: Profile &#125;;let pValue4: Profile3 = `hello`;// # 4// name의 string 타입을 전달, 타입이 string일 때 접근 가능한 내장 속성 이용 가능type Profile4 = keyof Profile[`name`];let pValue5: Profile4 = `length`;let pValue6: Profile4 = `abcd`; // error non-nullable 타입타입스크립트 2.0 이전에는 null 이나 undefined는 모든 타입의 변수에 할당할 수 있었음 그러나, tsconfig.json에 strictNullCheck을 true로 바꾸면, null과 undefined가 자동으로 모든 타입의 할당되지 않고 별도로 타입으올 관리해줘야함. never 타입never는 모든 타입의 하위 타입으로 사용할 수 있지만, any만 할당될 수 없다. 사용용도 함수에 닿을 수 없는 코드 영역이 있어 반환값이 존재하지 않을 때 함수에 throw객체가 반환되어, 오류가 발생할 때 1234567const neverFunc = (): never =&gt; &#123; while (true) &#123; &#125; // console.log(); &lt;- 닿을 수 없음&#125;let resultNever: never = neverFunc(); 123function error(message: string): never &#123; throw new Error(message);&#125; this 타입this 타입을 다형적 this 타입이라고도 함, 선언 위치에 따라 참조하는 대상이 달라지기 때문 인터페이스에 this 사용 예시1234interface ListItem &#123; getHead(): this; getTail(): this;&#125; 플루언트 인터페이스 패턴 (플루언트 패턴)그냥 자기자신 반환해서 체이닝하는 패턴 개인적으로 이런 형식으로 많이 사용했었음 123456789101112131415const Mycalc = () =&gt; &#123; return &#123; val: 0, plus(num) &#123; this.val += num; return this; &#125;, minus(num) &#123; this.val -= num; return this; &#125; &#125;&#125;Mycalc().plus(3).minus(2).val // 1","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 8장 정리","date":"2020-04-12T04:39:05.000Z","path":"wiki/Typescript quick start -8장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 8장 모듈📝253p. 모듈 필요성 유지보수 전역 스코프 오염 방지 재사용성 모듈러 프로그래밍 기반 과정 모듈 식별 모듈 분리 선언 외부 공개 📝254p. 내부 모듈, 외부 모듈 차이타입스크립트 1.5부터 Namespce라는 특징과 ES6 모듈 특지이 추가 ECMAScript 표준 용어집에 2가지 형태의 모듈 구분 내부 모듈 - namespace 외부 모듈 - export 내부모듈, namespace란 여러 파일에 걸쳐 하나의 이름을 공유, reference를 통해 참조 외부모듈은 파일마다 이름 공간이 정해짐, import를 통해 참조 그러므로, namespace는 프로젝트와 분리해 라이브러리 단위의 모듈을 구성할 때 좋음 @types 폴더에서 구분하여 타입선언 등 을 하는 듯 하다 📝259p. Namespace1namespace Hello &#123;&#125; namespace = module키워드는 다르지만, 역할과 기능상 차이가 없습니다 키워드 중복 이유ES2015에서 namespace 용어가 표준으로 채택되면서, 원래 Typescript 1.5에서 사용하던 module 용어가 자연스럽게 Deprecated됨 그런데, Typescript 타입 만드는 example code를 보면 아직은 module이라는 용어가 많이 쓰이는 듯 하다 참고링크 - chart.js 여기는 왜 module과 namespace를 동시에 사용한걸까? 123456789// namespace 사용 예시namespace Hello &#123; function print() &#123;&#125;&#125; // module 사용 예시module Hello &#123; function print() &#123;&#125;&#125; ES6 변환 결과 1234var Hello;(function: Hello) &#123; funtion print() &#123;&#125;&#125;(Hello || (Hello = &#123;&#125;)); // 모듈이 있으면 전달, 없으면 초기화 = 느슨한 확장 loose argument 📝261p. 한 파일에 여러 네임스페이스 선언네임스페이스마다 구분이 필요하게 되므로, export 선언 필요 12345678910111213141516namespace MyInfo1 &#123; export let name = `name1`; export function getName() &#123; return MyInfo2.name; &#125;&#125; namespace MyInfo2 &#123; export let name = `name2`; export function getName() &#123; return MyInfo1.name; &#125;&#125; console.log(MyInfo1.getName());console.log(MyInfo2.getName()); 변환시 var로 변환되어 호이스팅 특성때문에 순서와 상관없이 서로 호출 가능 📝263p. ★ 네임스페이스 여러 파일에 선언프로젝트 규모 커지면, 파일 단위로 모듈을 분할 tsc 명령시, 타입스크립트 컴파일러가 자동으로 네임스페이스간 참조 관계를 고려함 그러나, 개별 파일을 컴파일시에는 ///&lt;reference path=&quot;to/path&quot; /&gt;가 필요함 파일 상단의 표시하면 됨 그러나, 사실 tsc 명령어로도 같이 123ts-node car2.ts # undefined, undefined 출력tsc --out out.js car2.ts # 합쳐 컴파일 필요 ts-node car2.ts tsc -out out.js car2.ts 컴파일 후에도, 결과를 명시적으로 표시되게 하려면, 네임스페이스를 모듈로 선언하고 import를 선언 필요 (다음장에서 설명됨) 📝268p. 네임스페이스 모듈사용법12345678// car1.tsexport namespace Car &#123; export let auto: boolean = false; export interface ICar &#123; name: string; vendor: string; &#125;&#125; 12345678910111213import * as ns from './car1';// namespace를 한번 더 선언해서 사용? 이유가 있나?namespace Car &#123; console.log(ns.Car.auto); class Taxi implements ns.Car.ICar &#123; name: string; vendor: string; &#125;&#125; console.log(ns.Car.auto); 📝271p. 네임스페이스 이름 확장네임스페이스 이름은 .을 허용, 이름 계층 확장하는데 사용 사용 예시 123// 순서 바뀌어도 문제는 없지만, 상위에서 하위로 선언하는게 맞음namespace Animal&#123;&#125;namespace Animal.Pet&#123;&#125; 그러나 상속에 개념이 전혀 아니고, 서로 다른 네임스페이스이므로, 변수나 메소드 공유 X 📝274p. 브라우저에서 네임스페이스 모듈 호출 네임스페이스간 결국 js에는 없는 개념으로, 순서대로 js 스크립트 호출해서 사용해야한다는 것 같음 📝276p. 모듈 사용법개별 export12export interface ICar &#123;&#125;export function Test() &#123;&#125; 1import &#123; ICar, Test &#125; from '../to/path'; 함께 export1234let ver: string = `1.0`;let display = () =&gt; `hello`;export &#123; ver, display &#125;; 1import &#123; ver, display &#125; from '../to/path'; 모두 export12export let ver: string = `1.0`;export let display = () =&gt; `hello`; 1234import * as m from './to/path'console.log(m.ver);console.log(m.display()); 모듈 재노출12export * from '../to/path';export * from '../to/path'; 1import * as m from './to/path'; 모듈 파일을 가져와서 다시 export 하는 예시, 최상위에 모듈에서 많이 사용됨 📝281p. ★네임스페이스로 감싸서 재노출 namepsace 간 class보다 상위의 개념이기 때문에 감싸서 노출하면 편한 것 같다 1234// car-info.module.ts &lt;- 모듈 파일 명명법export namespace CarInfo &#123; export function hello() &#123;&#125;&#125; 123import &#123; CarInfo &#125; from './car-info.module';CarInfo.hello(); 📝283p. 디폴트 무법export-equals, import-equals 문 default 이전에 사용됬던 방식인 것 같은데, 몰랐던 부분 - 가끔 다른 프로젝트에서 종종 보였는데 이런 의미였구나 123456export = Chart;// 동일export default Chart;export &#123; Chart as default &#125;; 212345import Validator from './validator';// 동일import &#123; default as Validator &#125; from './validator'; 주의사항모듈 하나당 default는 하나만 선언 가능 📝289 ~ 313p. 모듈시스템 생략 모듈 시스템은 각 파트마다 다르기 때문에 웹개발자라면 ES2015모듈을, Node.js개발자라면 CommonJs 모듈 형식을 기본으로 알고, 나머지는 상황에 따라 알아야할 것 같다","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 7장 정리","date":"2020-04-05T04:39:05.000Z","path":"wiki/Typescript quick start -7장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 분량이 많아, 이미 아는 내용이나 자주 사용하는 부분은 생략함 7장 클래스와 인터페이스 목차📝183p. 타입스크립트의 객체지향 프로그래밍 지원객체지향의 목적은 코드 중복을 최소화 ES6에서 class 키워드가 추가되면서 부족한 점이 존재 객체지향 프로그래밍 요소 Js(ES6) Ts 클래스 class class 인터페이스 ★지원안함 interface 인터페이스 구현 ★지원안함 implements 상속 extends extends 생성자 constructor(){} constructor(){} 접근 제한자 ★지원안함 private, public, protected final 제한자 ★지원안함 readonly(Ts 2.0부터) static 키워드 static static super 키워드 super super 제한자의 경우, 실제 Js로 변환됬을 경우, 사라지는 부분으로 개발상에서만 제한의 의미가 있는 것이 아쉽다 📝p187. 기존Js(prototype) vs class 비교12345678910111213141516// 기존 Js Prototype 객체지향 프로그래밍var Rectangle = (function() &#123; function Rectangle(x, y) &#123; this.x = x; this.y = y; &#125; Rectangle.prototype.getArea = function() &#123; return this.x * this.y; &#125;; return Rectangle;&#125;)();var rectangle = new Rectangle(1, 5);var area = rectangle.getArea();console.log(area); 모듈 패턴은 클로저를 이용해 비공개된 내부 메소드를 캡슐화하여, 전역공간을 더럽히지 않는 장점 존재 123456789101112131415161718192021// class 객체지향 프로그래밍interface Rectangle &#123; x: number; y: number; getArea(): number;&#125;class Rectanlge &#123; x: numberl y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125; getArea(): number &#123; return this.x * this.y; &#125;&#125; 📝p188. 상속(extends), 포함(2) 관계상속 생략 포함 관계 합성(composition) - 강한관계 집합(aggregation) - 약한관계 합성12345678910class Engine&#123;&#125;class Car &#123; private Engine; constructor() &#123; this.engine = new Engine(); // 인스턴스 생성 &#125;&#125;let myCar = new Car();myCar = null; // null이 되면 포함된 클래스 함께 제거 집합12345678910class Engine&#123;&#125;class Car &#123; private engine: Engine; constructor(engine: Engine) &#123; this.engine = engine; // 인스턴스 생성 &#125;&#125;let engine = new Engine(); // engine 인스턴스 별도로 선언let car = new Car(engine); // 인스턴스 생성시, 포함되는 클래스를 같이 전달 위 코드(합성)과의 차이점은 집합은 car 객체가 제거되더라도,engine 객체는 외부에서 선언되었기 때문에 제거되지않음 (수명주기를 함께하지 않기때문에 약한관계) 실무에서는 어디에 주로 사용될까? 📝p192. 접근 제한자 접근 제한자 특징 상속 여부 외부 객체 접근 public 외부 또는 자식클래스에서 접근 가능 O O protected 자식 클래스에서 접근 가능 O X private 해당 클래스에서만 접근 가능 X X 📝p195. 축약 코딩기법챕터와 상관없지만, 관련 있는 변수 묶어서 선언하기 좋아보여서 기록 1let [cWidth, cLength, cHeight] = [1, 2, 3]; 📝p195. 접근 제한자 선언 &gt; 클래스 매개변수가 됨123456789class Cube &#123; constructor(public width: number) &#123;&#125; getWidth() &#123; return this.width; &#125;&#125;let cube = new Cube(6);console.log(cube.width); // 6 📝p197. get/set 코딩스타일 매개변수/getter/setter 한꺼번에 모아서 관리 123456789class PC &#123; ram = `0G`; get ramCapcity() &#123; return this.ram; &#125; set ramCapcity(value) &#123; this.ram = value; &#125;&#125; 📝p197. 부모 클래스 멤버 변수 이용super() 키워드와 this 사용 super는 부모 클래스의 공개 멤버(public)에만 접근 가능 this는 부모에게 상속받은 멤버와 현재 클래스 모두 접근 가능 📝p199. 기본 접근 제한자잘못 알고 있던 사항 constructor 매개변수에서 접근 제한자를 설정 안할시, default가 public일줄 알았는데 private 임 접근 제한자를 생략할 경우, 생성자 외부에서 매개변수에 접근할 수 없음! 📝p202. 추상 클래스를 이용한 공통 기능 정의 언제 사용될까? 실무에서 자주 사용되는 케이스가 궁금 구현 메소드는 실제 구현 내용을 포함 추상 메소드는 선언만된 메소드, 그러므로 자식 클래스에서 추상 메소드를 받아 별도 구현해야함 ! 추상 메서드나 추상 멤버 변수는 자식 클래스에서 사용(overriding)할 수 있게 public으로 선언해야함 추상 클래스에 기반은 둔 구현 방식은 템플릿 메서드 패턴으로 많이 알려짐 123456789101112131415161718192021222324abstract class AbstractBird &#123; abstract name: string; abstract flySound(sound: string); // 구현 메소드가 있어도 상관이 없나보네 fly(): void &#123; this.flySound(`$&#123;this.name&#125;: 파닥`); &#125; &#125;class RealBird extends AbstractBird &#123; constructor(public name: string) &#123; super(); &#125; // 오버라이딩 flySound(sound: string) &#123; console.log(`$&#123;this.name&#125; 날아감`); &#125;&#125;let dogBird = new RealBird(`새`);dogBird.fly(); // 새 날아감 📝 p205. Interface 다중 상속 몰랐던 부분 자식 인터페이스는 여러 부모 인터페이스를 다중 상속 가능 1234567891011interface Car &#123; speed: number &#125;interface SportsCar &#123; acceleration: number &#125;interface MyOptimizedCar extends Car, SportsCar &#123; waterproof: boolean;&#125;let myCar = &lt;MyOptimizedCar&gt;&#123;&#125;; // ?? 인터페이스만으로 인스턴스를 만들 수 있는건가?myCar.speed = 100;myCar.acceleration = 100;myCar.waterproof = true; ! 만약 다중 상속 받을 때, 같은 이름의 메소드를 상속받으면 재정의해야함 12345678910111213141516171819202122232425262728293031interface Dog &#123; run(): void; getStatus(): &#123; runningSpeed: number; &#125;;&#125;interface Bird &#123; fly(): void; getStatus(): &#123; flightSpeed: number; &#125;;&#125;interface DogBird extends Dog, Bird &#123; getStatus(): &#123; runningSpeed: number, flightSpeed: number; &#125;&#125;class NewAnimal implements DogBird &#123; run(): void &#123;&#125; fly(): void &#123;&#125; getStatus(): &#123; runningSpeed: number, flightSpeed: number; &#125; &#123; return &#123; runningSpeed: 10, flightSpeed: 20 &#125; &#125;&#125; 📝p212. 클래스를 배열 요소로 보고 배열 타입 선언 몰랐던 부분 클래스 자체를 타입 선언 부분에 넣을 수 있음 1234567891011class Person &#123; public full: string; constructor(public name: string, public city: string) &#123; this.full = name + `($&#123;city&#125;)`; &#125;&#125;let personArray: Person[] = [ new Person(`kim`, `name`), new Person(`kang`, `name`)]; 📝p215. 인터페이스에 함수 타입 정의익명 함수에 대한 함수 타입 정의 ()를 사용하면 정의 할 수 있음 ! 매개 변수 이름과 타입이 일치하지 않더라도 상관이 없음 (??? 이유가 뭘까) 1234567891011interface IFormat &#123; (data: string, toUpper?: boolean): string;&#125;let format: IFormat = function (data: string, toUpper: boolean) &#123; ...&#125; let format: IFormat = function (str: string, isUpper: boolean) &#123; ...&#125; 📝p216. 오버라이딩오버라이딩 = 부모에서 상속받아, 자식 클래스에서 새로 구현하는 방법 두 가지 조건 필요 조건1: 부모클래스의 매개변수 타입이 같거나 상위 타입이여야함 조건2: 부모클래스의 매개변수 개수가 같거나 많아야 함 📝p219. 오버로딩오버로딩 = 메서드의 이름은 같지만 매개변수의 타입과 개수가 다르게 정의하는 방법 12345678// 점점 상위의 타입으로 선언typeCheck(value: number);typeCheck(value: string);typeCheck(value: any): void &#123; if (typeof value === `number`) console.log(`this is number`); else if (typeof value === `string`) console.log(`this is string`); else console.log(`nothing`);&#125; 📝p222. 인터페이스를 클래스에서 구현하여 오버로딩123456789interface IPoint &#123; getX(x: any): any;&#125;class Point implements IPoint &#123; getX(x?: number | string): any &#123; ... &#125;&#125; ! 인터페이스를 이용하면 선언과 구현을 분리하고 구현부의 구조를 강제 이 점에서 로직과 구조가 섞여 있는 클래스를 상속해 오버로딩하는 것보다 구조만을 가지고 있는 인터페이스를 이용하는 것이 복잡고 낮습니다. 📝p224. 다형성종류 클래스의 다형성 인터페이스의 다형성 매개변수의 다형성 클래스의 다형성12345678910111213141516171819202122class Planet &#123; stopTransduction(): void &#123; console.log(`stop - planet`); &#125;&#125;class Earth extends Planet &#123; public features: string[] = [`soil`, `water`, `oxyzen`]; stopTransduction(): void &#123; console.log(`stop - earth`); &#125; earthStop(): void &#123; console.log(`stop2 - earth`); &#125;&#125;let earth: Planet = new Earth(); // ★ Earth 인스턴스를 생성했지만, 타입은 상위의 Planet임earth.stopTransduction(); // stop - earth, 인스턴스의 메소드를 사용console.log(earth.features); // Error, 접근 불가earth.earthStop(); // Error, 오버라이딩 되지 않은 메소드는 접근 불가 부모 클래스의 타입을 지정받은 인스턴스는 실제 동작은 부모 클래스 기준으로 실행됨 그래서 자식 클래스 멤버 변수(features)에 접근할 수 없음 그러나, 메소드 자체는 자식 인스턴스의 것이 실행됨 (런타임 다형성(runtime polymorphism)), ex. duck typing 인터페이스의 다형성 클래스와 다르지 않아 코드만 적고 생략 12345678910111213141516171819interface IPerson &#123; getAlias: () =&gt; string; getAge(): number;&#125;class PoliceMan implements IPerson &#123; getAlias = () =&gt; `happy`; getAge(): number &#123; return 10; &#125; hasClub() &#123; return true; &#125;&#125;let policeMan: IPerson = new PoliceMan();console.log(policeMan.hasClub()); // Error, 접근 불가 매개변수의 다형성 (유니언 타입)1display(data: string | number) &#123;&#125; 문제점타입 가드가 빡셈 12345678910class MonitorDisplay &#123; display(monitor: Led | Oled | Uhd) &#123; if (monitor instanceof Led) &#123;&#125; else if (monitor instanceof Oled) &#123;&#125; else if (monitor instanceof Uhd) &#123; let myMonitor: Uhd = &lt;Uhd&gt;monitor; return myMonitor.getName(); &#125; &#125;&#125; type 키워드시 축약은 가능하지만 근본적인 해결책은 될 수 없음(클래스 타입 추가시마다, 매번 업데이트 필요) 123456// 여긴 또 신기하게 대문자로 명명했네..type MultiTypes = Led | Oled | Uhd;class MonitorDisplay &#123; display(monitor: MultiTypes) &#123; ...(if들) &#125;&#125; ★★ 매개변수의 다형성 (인터페이스)123456789101112131415161718192021222324interface Monitor &#123; getName(): string;&#125;class Led implements Monitor &#123; constructor(private name: string) &#123;&#125; getName(): string &#123; return `LED: ` + this.name; &#125;&#125;class Oled implements Monitor &#123; constructor(private name: string) &#123;&#125; getName(): string &#123; return `Oled: ` + this.name; &#125;&#125;class MonitorDisplay &#123; display(monitor: Monitor) &#123; let myMonitor: Monitor = monitor; return myMonitor.getName(); &#125;&#125; if문 없이 코딩이 가능함 📝p236. getter/setter 사용 이유굳이 this.name = &#39;anything&#39; 처럼 멤버 변수를 사용하지 않고 get/set 키워드를 사용하는 이유 값을 설정하거나 읽을 때, 로직을 추가 가능(= 조건 추가 가능) 123456789get name(): string &#123; return this.studentName;&#125;set name(name: string) &#123; if (name.includes(`happy`)) &#123; this.studentName = name; &#125;&#125; ES5 변환시Object.defineProperty 참고 1234567891011121314Object.defineProperty(Student.prototype, `name`, &#123; get: function() &#123; return this.studentName; &#125;, set: function(name) &#123; if (name.includes(`happy`)) this.studentName = name; &#125;, enumerable: true, // true: 객체 키 열거 가능, default: false configurable: true // true: 이 속성 값 수정/삭제 가능, default: false&#125;)for (var prop in Student.prototype) &#123; console.log(prop); // 여기에 enumerable 하지 않으면 표시되지 않음&#125; 📝p240. staticstatic 키워드는 객체 생성 없이 접근 가능하므로 메모리 절약 효과 존재 객체 생성 없이 바로 접근 가능 static 멤버 변수는 인스턴스간 값 공유 12345678910111213class Circle &#123; static circleArea: number = 0; get area(): number &#123; return Circle.circleArea; // this가 아닌 Circle을 사용했음 &#125; static set area(pArea: number) &#123; Circle.circleArea = pArea; &#125;&#125;Circle.area = 100;let circle = new Circle();console.log(circle.area); // 100, 공유되는 것을 확인 📝p242. 싱글톤 패턴static 키워드를 활용하면 유일한 상태 정보 저장 가능 이렇게 하기위해서는 객체 생성을 막고, 클래스 변수, 메소드 등 모두를 static으로 선언 단일 상태 관리에는 좋지만, 인스턴스 생성은 불가능 생성법 부지런한 초기화 (eager initalization) - 클래스 선언시 초기화 게으른 초기화 (lazy initalization) - 메소드 호출시 초기화 Eager Initalization1234567891011class EagerLogger &#123; private static uniqueObj: EagerLogger = new EagerLogger(); // 내부에서 자체적 선언 // private를 붙여 인스턴스 생성 방지 private EagerLogger() &#123;&#125; // static으로 외부 접근 허용 public static getLogger(): EaggerLogger &#123; return this.uniqueObj; &#125;&#125; Lazy Initalization1234567891011121314class LazyLogger &#123; private static uniqueObj: LazyLogger; private LazyLogger() &#123;&#125; public static getLogger(): LazyLogger &#123; // 생성된 적이 없으면 새로 생성, 타입은 LazyLogger이므로 ==로 타입검사 피함 if (this.uniqueObj == null) &#123; this.uniqueObj = new LazyLogger(); &#125; return this.uniqueObj; &#125;&#125; 📝p247. readonly vs const const가 사용되는 곳은 readonly를 사용하지 못한다고 이해하면 편한 것 같다 특성 const readonly 상수 선언 가능 가능 초기화 강제성 필수 선택 값 재할당 불가능 가능(?) 선언 가능 대상 변수 멤버 변수객체 리터럴새타입 선언 불가능 대상 멤버 변수객체 리터럴새타입 변수 사용 용도 상수 읽기 전용 속성 컴파일 선언 유지 유지 사라짐 지원 표준 ES6 TS 2.0 📝p250. readonly 제거되는 경우type 에일리어싱시 사라짐 12345678910let emotion: &#123; readonly name: string &#125; = &#123; name: `sad` &#125;;function aliasing(pEmotion: &#123; name: string &#125;) &#123; pEmotion.name = `happy`;&#125;console.log(emotion.name); // sademotion.name = `happy`; // Erroraliasing(emotion);console.log(emotion.name); // happy, 변경됨","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 6장 정리","date":"2020-03-22T11:39:05.000Z","path":"wiki/Typescript quick start -6장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성했습니다. 6장 함수 목차 사용법 (Js vs Ts 비교) 매개변수 초기값 지정 ...rest 매개변수 선택 매개변수 지정 오버로드 익명 함수 화살표 함수 타입 선언 콜백 함수 📝p151. 함수 (Js vs Ts 비교)js의 경우12345678function max(x, y) &#123; return x &gt; y ? x : y;&#125;max(1, 10); // 10max(1, 10, 12); // 10, 이후 인자값은 무시당함max(`a`, `b`); // `b`max(`c`, `aaa`); //`c`, 으음... 문자열 첫번째값의 아스키 코드값인가? 결과 ts의 경우123456function max(x: number, y: number): number &#123; return x &gt; y ? x : y;&#125;max(1, 10); // 10max(1, 10, 12); // Error: 인자 개수 에러max(`a`, `b`); // Error: 인자 타입 에러 결과 📝p156. 매개변수 초기값ES6부터 매개변수의 값을 지정 받지 않아도, 초기값으로 값을 지정해줄 수 있게됨 코드도 간결해지고 complexity도 낮아짐 ES6 이전1234function test(param) &#123; param = param || `초기값`; console.log(param);&#125; ES6 이후123function test(param = `초기값`) &#123; console.log(param);&#125; 📝p159. 나머지 매개변수ES6부터 생긴 기능, 정의되지 않은 매개변수를 받기 편해짐 ES6 이전arguments는 잘 사용하지 않는 방식으로 알려짐 (보안) 123function test() &#123; console.log(arguments);&#125; ES6 이후123function test(...args) &#123; console.log(args);&#125; 나머지 매개변수 타입 지정법 나머지 매개변수도 타입 지정이 가능한 것을 처음 알았다 1234// 처음 1개 값을 지정하면, concat()같이 아무것도 받지않았을 때는 유효하지않음function concat(a: string, ...restStr: string[]): string &#123; return `$&#123;a&#125; $&#123;restStr.join(` `)&#125;`;&#125; 📝p162. 선택 매개변수js의 경우12345678function sum(a, b) &#123; console.log(arguments); return a + b;&#125;sum(1); // NaNsum(1, 2); // 3sum(1, 2, 3) // 3, 이후 파라미터를 사용되진 않지만, 받음 ts1234567function sum(a: number, b?: number): number &#123; return a + b;&#125;sum(1); // NaN, js와 결과는 동일sum(1, 2); // 3sum(1, 2, 3) // Error 인자 초과 📝p164. 함수 오버로드 잘 몰랐던 부분 함수명은 같지만, 매개변수와 반환 타입이 다른 여러개의 함수를 선언 가능, 런타임 비용이 별도 추가되지 않음 가장 일반적인 타입을 가장 아래에 선언(ex. any가 가장 아래), 위일 수록 구체적 (순서 중요!) 12345678function add(a: string, b: string);function add(a: number, b: number);function add(a: any, b: any): any &#123; return a + b;&#125;console.log(add(1, 2)); // 3console.log(add(`test1`, `test2`)); // test1test2 📝p170. 화살표 함수 유의점12345// bad caseconst test = x =&gt; &#123; x; &#125;; // block&#123;&#125;을 사용할 경우, 무조건 return이 필요함!// good caseconst test = x =&gt; &#123; return x; &#125;; 📝p171. filter, reduce filter MDN reduce MDN 📝p173. 객체 리터럴 선언 개인적으로 객체 지향적으로 짤 때 좋은 코딩 스타일이라고 생각되는 문법 12345678let person = &#123; name: `Taeuk`, hello: function (yourName) &#123; console.log(`Hello $&#123;yourName&#125;, I'm $&#123;this.name&#125;`); &#125;&#125;person.hello(`minsu`); 주의사항 function을 사용했기 때문에 this.name을 사용할 수 있었던 부분 만약 화살표 함수를 사용한다면 이렇게 뜰 것 이다. (현재는 this값이 window(최상위)로 잡은 케이스) Typescript에서 this 타입 선언 잘 몰랐던 부분 1234interface PersonType &#123; name: string; hello(this: PersonType, yourName: string): string;&#125; 📝p177. type 명명법&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 몰랐던 부분 type는 앞이 대문자가 아님 type는 대문자로 시작, 책은 소문자로 시작되서 이상해서 레퍼런스를 찾아봄 대문자로 시작하는게 표준 케이스인 것 같음 69d06d879cf539e94f86963fe76ebff54737f05b 1type calcType = (a: number, b: number) =&gt; number; &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ======= 69d06d879cf539e94f86963fe76ebff54737f05b 📝p179. jquery -&gt; VanillaJS 음… 왜 굳이 예시를 Jquery로 들었는지 몰라서 작성 Jquery123$(`#myButton`).click(function() &#123; alert(`버튼`);&#125;) js123document.querySelector(`#myButton`).addEventListener(`click`, () =&gt; &#123; window.alert(`버튼`); &#125;); 📝 180. 콜백함수의 다른 예시(ex. Chrome API) Promise, async/ await 으로 바뀌는 추세이지만, 아직도 많은 부분에 callback 함수가 남아있다.","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/categories/Typescript/"}]},{"title":"Accordion FE 2차 Prototype 준비사항","date":"2020-03-18T03:39:05.000Z","path":"wiki/Accordion-FE_prototype-v2_계획/","text":"Accordion-FE prototype-v2 준비사항요약예상 일정: ~ 2020. 04 . 03. 금 까지 개발예정: 메인 새기능 CRUD 테이블 컴포넌트 구현 - GET/POST/DELETE 대응 /admin/overview 페이지 구현 /login 페이지 구현 - keycloak 연동 모니터링 대시보드 - Active server chart 구현 개발예정: 부가 새기능 REST API 연결 - 현재는 heml chart 부분 가능 피드백 필요사항 엔지니어분들이 주시는 데이터를 표시하는 표준적인 차트에 대한 지식이 부족 (예시. xlog, ElapsedTime, etc) 기존 아코디언을 제외하고 이를 참고할만한 좋은 예시(링크, 이미지)가 필요 예시. “이 부분은 제니퍼 소프트에 어떤 차트같이 만들었으면 좋겠다.” 오픈시프트에서 참고할만 요소(링크, 이미지) 필요 - ∵ 오픈시프트에 대한 지식 부족 개선 필요사항 차트의 zoom 기능이 기존 스크롤과 중복되어 발생되는 버그들이 존재하여, 드래그하여 시간을 이동하는 기능만 넣고 시간축 확대 기능은 제외할지 고민 중 메인 페이지 - Pod, Service, Project, Node 엘리먼트, Running/ Fail 나누어서 클릭하여 모달창 띄울 예정 현재 SPA 라우팅 속도 문제 해결 필요 - 화면의 FOUS 발생없이 한번에 화면 전환이 되야함 기획 필요사항 프로젝트 - 앱 - 앱 추가 기능에 현재 테이블 형태가 아닌, 스크롤이 존재하지않고 탭으로 관리하는 형태가 되면 어떨지 고려 중 (▼ 아래 그림은 예시)","tags":[{"name":"Accordion","slug":"Accordion","permalink":"https://typescript-study.github.io/tags/Accordion/"}],"categories":[{"name":"Accordion","slug":"Accordion","permalink":"https://typescript-study.github.io/categories/Accordion/"}]},{"title":"Quick Start Typescript ~ 5장 정리","date":"2020-03-15T03:39:05.000Z","path":"wiki/Typescript quick start -5장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성했습니다. Typescript 학습하는 목적으로 이해도가 높지 못해, 작성시 참고한 링크를 작성했습니다. 📝p134. 산술 연산자ES7의 지수 연산자(Math.pow)를 지원, **를 이용 사용 예시 1console.log(10 ** 3); // 1000 📝p136. 비교 연산자 다른 언어와 다르게, 자바스크립트는 === 등호 3개가 존재, ==와 다른 점은 ==은 값만 비교한다면 ===은 값과 타입을 비교하는 것이 다름 12'1' == 1; // true'1' === 1; // false 위 사항은 자바스크립트 또한 마찬가지지만, 타입스크립트는 같은 타입과의 비교만 지원한다. 📝p137. 논리 연산자 논리 연산자는 주로 변수 선언과 함께 함수 초기값 선언에 많이 사용된다. 사용 예시 12345678// 이런식으로 기본값이 없으면, default를 만든다. 라는 것으로 선언 가능const value: string = value || 'default';// 부정 연산자는 depth를 깊게하지 않기 위한, if문에 많이 사용됨if (!isLogin) &#123; console.error(`no login!`); location.href = `/login`; // login 라우팅으로 이동&#125; 📝p139 디스트럭처링종류 객체 디스트럭처링 배열 디스트럭처링 1. 객체 디스트럭처링1234let &#123; id, country = 88 &#125; = &#123; id: `happy` &#125;;console.log(id); // happyconsole.log(country); // 88 rename12345let &#123; id: newName1, country: newName2 &#125; = &#123; id: `happy`, country: 88 &#125;;console.log(newName1); // happyconsole.log(newName2); // 88console.log(id, country); // error Not defined 함수 파라미터 초기값 설정12345test(&#123; name: `happy` &#125;); // happy, none 출력function test(&#123; name, country = `none` &#125;) &#123; console.log(name, country);&#125; type 키워드 활용12345678type C = &#123; a: string, b?: number &#125;;fruit(&#123; a: `apple`, b: 10 &#125;); // apple 10fruit(&#123; a: `apple`&#125;); // apple undefinedfunction fruit(&#123; a, b &#125;: C) &#123; console.log(a, b);&#125; 2. 배열 디스트럭처링123456789101112131415161718192021222324let numbers = [`one`, `two`, `three`, `four`, `five`];// 이전 방식let num1 = numbers[0]; // onelet num2 = numbers[1]; // two// 이후 방식let [num1, num2] = numbers; // one, two// 결과 동일console.log(num1, num2); // one, two// 중간 빼오기let [, , num3, num4, ] = numbers;console.log(num3, num4); // three, four// 교체[num4, num3] = [num3, num4];console.log(num3, num4); // four, three// 초기값 지정let [color1, color2 = `blue`] = [`black`];console.log(color1, color2); // black blue 📝p146. 전개 연산자배열123let [first, ...second] = [1, 2, 3];console.log(first, second); // 1 2, 3 객체123let numGroup = &#123; n1: 1, n2: 2, n3: 3&#125;;let &#123; n2, ...n13 &#125; = numGroup;console.log(n2, n13); // 2 &#123; n1: 1, n3: 3&#125;;","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 4장 정리","date":"2020-03-08T03:39:05.000Z","path":"wiki/Typescript quick start -4장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성했습니다. Typescript 학습하는 목적으로 이해도가 높지 못해, 작성시 참고한 링크를 작성했습니다. 📝p39. package.json프론트엔드에서 가장 먼저 살펴보는 파일 package.json 번들러: webpack.config.js or vue.config.js JS 로더: tsconfig.json, babel.config.js or .babelrc CSS 로더: postcss.config.js index.html - JS/CSS/Font 삽입 보기 그외 Lint(코딩 컨벤션): eslintrc.js package.json 작성 개인적으로 중요하다고 생각되는 부분이나 몰랐던 부분만 정리 이 사이트 (공식)에서 자세히 설명되어있다. +한글 사이트 name주의사항: name에는 대문자를 포함해서는 안된다. version버전 관리는 아래와 같은 Rule이 존재 모르고 있던 부분 scripts 개인적으로 가장 package.json 파일을 열었을 때, 가장 먼저 보는 항목 참고링크 npm-scripts npm-run-scripts 개발자가 설정해둔 커맨드 라인 명령어를 alias처럼 npm run &lt;key값&gt;으로 사용할 수 있다. 12345// package.json\"scripts\": &#123; \"test:make\": \"mkdir make-test-folder\"&#125; 123npm run test:make# mkdir make-test-folder 명령어가 실행되고, 현재 경로에 make-test-folder 디렉토리가 생긴다. dependencies실제 배포될 때 포함되는 패키지들 npm install or npm install --save 로 저장된 패키지들 devDependencies개발용으로 필요한 패키지들 (lint, test, bundle etc) npm install -D or npm install --save-dev로 저장된 패키지들 📝p40. npm 주요 명령어npm 주요 명령어를 짧게 칠 수 있다. (기본 aliases) 자주 사용하는 명령어라서 짧게 치면 편하다. 123456789101112131415# 이전npm install &lt;패키지명&gt;# 축약npm i &lt;패키지명&gt;# 여러 축약## 글로벌 설치npm i -g &lt;패키지명&gt;## devDependency 설치npm i -D &lt;패키지명&gt;## 삭제npm rm &lt;패키지명&gt; 그 외 명령어들 📝p48. tsconfig.json 설정타입스크립트 컴파일 옵션 정의된 파일 공식 홈페이지 참고: 간단히 정리된 블로그 removeComments의 경우 주석을 제거하여 컴파일 해주지만, 주석을 이용하여 webpack에서 번들링하는 경우가 존재하는 점을 유의 ex. /router/index.ts 1const DashboardView = () =&gt; import(/* webpackChunkName: \"dashboard\" */ '@/views/admin/dashboard/DashBoardView.vue'); 위와 같이 URL 라우팅별로, code split하여 특정 JS만 불러오게 하는 기능을 주석으로 처리할 수도 있다. *해당 라우팅으로 들어갔을 때, dashboard.js 파일만 불러오게하는 기능이다. 📝p76. 변수 선언 기존 JS(ES5) var 과 ES6에서 생긴 let, const 차이점이 중요 현재는 var은 잘 사용하지않는 편, 실제로 ESLint에서도 no-var option을 사용하여 사용 못하게 설정됨 var vs let, const 차이점 호이스팅 함수 레벨 스코프(var) vs 블록 레벨 스코프(const, let) 호이스팅 차이선언이 유효범위에서 최상단으로 이동하는 것 JS에서 대표적으로 호이스팅(끌어올림)으로 되는 것이 function과 var이 있다. 안되는 것으로는 class, const, let이 있다. var의 경우12345678910// 개발 작성 코드var test = `global`; // 이렇게 할당된 변수는 window.test 객체로 할당된다.console.log(window.test); // `global`func();function func() &#123; console.log(test); // (A) 여기 표시값? var test = `local`; console.log(test); // (B) 여기 표시값? &#125; 1234567891011121314// 실제 실행되는 코드var test; test = `global`;console.log(window.test); // `global`function func() &#123; // 함수도 호이스팅 되는 것을 알 수 있다. var test; console.log(test); // (A) undefined test = `local`; console.log(test); // (B) `local` &#125;func(); (A) 부분에서 func내에서 지역변수로 test 변수가 호이스팅 했기 때문에 글로벌 변수 test를 가져오지 못하는 것을 알 수 있다. const, let의 경우1234567891011121314151617const testConst = `global-const`;let testLet = `global-let`;console.log(window.testConst); // undefined constconsole.log(window.testLet); // undefined let var과 다르게 window 객체에 할당되지 않는다.// func(); // Error, 아직 선언되지 않음const func = () =&gt; &#123;// console.log(testConst); // Error, 아직 선언되지 않음// console.log(testLet); // Error, 아직 선언되지 않음 const testConst = `local-const`; let testLet = `local-let`; console.log(testConst); // `local-const` console.log(testLet); // `local-let`&#125;func(); 함수 레벨 스코프(var) vs 블록 레벨 스코프(const, let)var의 경우12345678func();function func() &#123; // 변수 범위 = 함수 안 if (true) &#123; var test = `any`; &#125; console.log(test); // `any`&#125; const, let의 경우12345678910func();function func() &#123; if (true) &#123; // 변수 범위 = &#123;&#125; 블록 안 const testConst = `const`; let testLet = `let`; &#125; console.log(testConst); // Error, not defined console.log(testLet); // Error, not defined&#125; 📝p86. 타입 계층도 참고하면 좋은 링크 타입 체크가 Javascript에서 없던 부분이라 아직 많이 부족한 부분 any가장 상위에 있는 타입 primitive type string, number, boolean symbol enum 문자열 리터럴 Object Array Tuple Functopn 생성자 &lt;- ? Class Interface Union2개 이상의 타입 하나의 타입으로 지정 1const x: string | number; intersection두 타입을 합쳐 하나의 타입으로 만듦 12345678910interface Dog &#123; leg: number;&#125;interface Bird &#123; wing: number;&#125;let dogBird: Dog &amp; Brid = &#123; leg: number; wing: number;&#125; Primitive type(생략) string, number, booleansymbol유일하고 불변적인 식별자 (자세한 사항) ES6 이상에서부터 지원 1234let test = Symbol(`test`);let test2 = Symbol(`test`);console.log(test === test2); // false 사용처 12345const RED = Symbol();const YELLOW = Symbol();const ORANGE = Symbol();// 그 자체로 식별자 역할을 함 실제 개발상에서 사용해본 적이 없어서 아직 잘 모르겠다. 사용 사례에 대한 링크 type특정 문자열만 허용하는 타입 1type EventType = \"keyup\" | \"mouseover\"; enum123enum Color &#123; Red = 1, Green, Blue &#125;;let color: Color.Green;console.log(color); // 2 Object와의 차이점? (여기참고) object는 속성 자유롭게 변경 가능, enum은 그렇지 않음 enum은 항상 리터럴 타입 사용 enum의 속성값으로는 문자열 또는 숫자만 허용됨 사용 이유 123456789101112131415161718const korean = `ko`const english = `en`// 코드 중복type Language = `ko` | `en`// 코드기 길어짐type Language = typeof korean | typeof englishconst code: Language = korean// enum 사용시 가독성이 증가함enum Language &#123; korean = `ko`, english = `en`&#125;const code: Language = Language.korean Object TypeArrayarray type1let array; string[] = [`a`, `b`, `c`]; generic array type &lt;&gt;1let array: Array&lt;string&gt; = [`a`, `b`, `c`]; 차이점: primitive 타입 외에 object 타입도 받을 수 있다. 1let array: Array&lt;() =&gt; string&gt; = [() =&gt; `a`, () =&gt; `b`, () =&gt; `c`]; Tuplen개에 대한 배열 타입 1234let array: [string, number] = [`text`, 10];array = [1, `t`]; // error - 각 index에 대한 타입이 안맞음array = [`t`, 10, `e`, 1]; // error - index를 초과하여 받음 이번 장에서 다루지 않는 것들 생략 (생략) Function(생략) 생성자(생략) Class(생략) Interface📝p114 undefined !== nullundefined는 선언은 됬지만, 값이 할당되지 않은 상태 null은 선언과 값이 없다고 할당된 상태 12undefined === null; // falseundefined == null; // true === 비교 연산자는 type까지 값은지 체크해주지만, ==는 값만 체크 ex. 121 == `1`; // true1 === `1`; // false 📝p123 for … in 문 주의사항 이전에 이슈 걸렸던 사항으로 작성 for ... in 문은 없는 인덱스는 출력하지 않는다. ex. 123for (i in [1,,,4]) &#123; console.log(i);&#125; for ... of문은 출력","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://typescript-study.github.io/categories/Typescript/"}]}]}